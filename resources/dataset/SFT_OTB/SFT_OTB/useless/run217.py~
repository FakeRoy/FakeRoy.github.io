'''
Recurrent trackor
run.py
'''

from config217 import *
import pdb
####################################################
#####               Main Fun            ############
####################################################
if __name__ == '__main__':
    ####
    if not os.path.isdir(data_path):
        raise Exception('data not exist',data_path)

    #### 
    fdrs = next(os.walk(data_path))[1]
    fdrs = sorted(fdrs)
    n_fdr = len(fdrs)
    print("{}".format(n_fdr))
    #### build VGG model
    with tf.device(gpu_id):
        vgg = vgg19_tf.Vgg19( vgg_model_path, vgg_out_layers)
        vgg_sess = tf.Session(config = config)
    vgg_map_total, vgg_map_idx, vgg_map_nlayer = vgg.out_map_total, vgg.out_map_idx, vgg.out_map_nlayer
    
    ####
    for ifdr in idx_fdrs:#np.arange (start_sample,end_sample,step_sample):#n_fdr
	##
        fdr = fdrs[ifdr]
	#if fdr !='Freeman1':# and fdr!='':# and fdr !='Coke':# and fdr!='Football':
	#    continue
        fpath = os.path.join(data_path,fdr)
        f_rcts = glob.glob(fpath+'/groundtruth_rect*.txt')
        f_imgs = glob.glob(fpath+'/*.jpg')
        n_img = len(f_imgs)
        n_rct = len(f_rcts)
        f_imgs = sorted(f_imgs,key=str.lower)

        print("{}:{}:{}".format(ifdr, fdr, n_img))
	## read images >> X0
        for ii in range(n_img):
            img = read_image(f_imgs[ii],True,True,-1)
            if ii == 0:
                im_sz = np.asarray([img.shape[1],img.shape[0]])
                X0 = np.zeros((n_img,img.shape[0],img.shape[1],3),dtype=np.uint8)
            X0[ii,:,:,:] = img
        del img		
	################# each sequence ##############################
        for iseq in range(n_rct):
            str1 = 'result_%s_%d_%.3f.mat' %(fdr,iseq,update_factor)
            fname = os.path.join(cache_path,str1)
            if os.path.isfile(fname):
                print("{} existed result".format(fname))
                continue
	
	    #### log file
            str1 = 'log_%s_%s_%d.txt' %(pstr,fdr,iseq) #pstr=gcnn
            log_file = os.path.join(cache_path,str1)
            logger = Logger(logname=log_file, loglevel=1, logger=">>").getlog()
	    
	    #### load rct and convert it ctr style 
            gt_rcts0 = np.loadtxt(f_rcts[iseq])
            gt_rcts = np.floor(fun_rct2ctr(gt_rcts0)) 
 
	    #### set peak map
            target_sz = gt_rcts[0,2:]
            window_sz,padding_h, padding_w = fun_get_search_window2(target_sz,im_sz,None,None) 

	    #### cell_size ??
            #xx = np.prod(np.floor(window_sz/cell_size0+0.5))
            #print('xx:{}'.format(xx))
            #cell_size = np.round(cell_size0*np.sqrt(xx/max_win2))
            cell_size=window_sz[0]/fea_sz[0]
            print("cell_size:{}".format(cell_size))

            #if xx > max_win2:
            #    cell_size = np.round(cell_size0*np.sqrt(xx/max_win2)+0.5)
            #elif xx < min_win2:
            #    cell_size = np.floor(cell_size0*np.sqrt(xx/min_win2)+0.5)
            #else:
            #    cell_size = cell_size0 # Bolt

	    #### 
            pmap,pmap_ctr_h,pmap_ctr_w = fun_get_peak_map(window_sz,target_sz,cell_size,fea_sz,False)
            assert(pmap.shape[0]==fea_sz[0] and pmap.shape[1]==fea_sz[1])
            str1 = "target_sz: [%d, %d], window_sz: [%d, %d], pmap.shape: [%d, %d], cellsize: [%d] " %(target_sz[0], target_sz[1],\
                     window_sz[0], window_sz[1], pmap.shape[0], pmap.shape[1],  cell_size)
            logger.info(str1)

            #fea_sz = np.asarray([pmap.shape[1],pmap.shape[0]])
            prod_hw = fea_sz[1]*fea_sz[0]
            kernel_gamma2 = kernel_gamma/vgg_map_total
            #vgg_in_sz = fea_sz*vgg_scale_in2out
            pmap = pmap.reshape((-1,1)) 

	    #### cos_win
            cos_win = fun_cos_win(fea_sz[1],fea_sz[0],(1,fea_sz[1],fea_sz[0],1))*1.0e-3#/vgg_map_total

	    ####
            in_shape = (1,fea_sz[1],fea_sz[0],vgg_map_total)
            vgg_fea    = np.zeros(in_shape,dtype=np.float32) 


            #### graph 1
            gh1['height_width'] = (fea_sz[1],fea_sz[0])
            A1 = grid_graph(gh1, corners = False)
            L1 = laplacian(A1)

            del A1
            #pdb.set_trace() 
	    ####
            pred_rcts  = np.zeros((n_img,4),dtype=np.float32)
            pred_rcts[0,:] = np.copy(gt_rcts[0,:])
            cur_rct = np.copy(pred_rcts[0,:])
	    
            save_fdr = '%s_%d' %(fdr,iseq)
            save_path = os.path.join(cache_path,save_fdr)
            if not os.path.isdir(save_path):
                os.mkdir(save_path)

	    ############################## extract feature ##########################
            #### other vars: padding, vgg_in_sz, padding_type
	    #### ims: [n,h,w,3] or [h,w,3]; ctr_rcts: [n,4]; vgg_fea: [n,nmap,nh,nw] 
            def extract_feature(ims,ctr_rcts,vgg_fea):
                n = ctr_rcts.shape[0]
                l = len(ims.shape)
                if l == 4:
                    assert(ims.shape[0]==n)
                ## crop out patch
                patches = []
                for ii in range(n):
                    window_sz,_,_ = fun_get_search_window2(ctr_rcts[ii,2:],None,padding_h,padding_w) # ??
                    if l==4: 
                        patch = fun_get_patch(np.copy(ims[ii]),ctr_rcts[ii,0:2],window_sz)
                    else:
                        patch = fun_get_patch(np.copy(ims),ctr_rcts[ii,0:2],window_sz)
                    patches.append(patch)
                ## extract vgg feature: outdata >> list
                patches = vgg_process_images(patches,**img_param)     
                feed_dict = {vgg.images: patches}
                outdata = vgg_sess.run(vgg.out_layers, feed_dict=feed_dict)
                ## from list to array
                vgg_resize_maps(outdata,(fea_sz[1],fea_sz[0]), 'bicubic', vgg_fea)
                ## normalization of vgg feature ??
                vgg_fea[:,:,:,:] = vgg_fea*cos_win
                return patches
            
            #########################
            #ss = '_%s_%d' %(fdr,iseq)
            #nn['dir_name'] = create_dir(cache_path,ss)
            #nn['num_node'] = prod_hw
            #nn['Fin'] = vgg_map_total
            nn_d = nn_p*pca_energy #vgg_map_total
            nn_m = prod_hw
            assert(nn_d%nn_p ==0)
            nn_map = np.int32(nn_d/nn_p)
            ####
            target_sz_2=(1.0*fea_sz[0]/window_sz[0])*target_sz
            #pdb.set_trace()
            nn_K=np.round(max(target_sz_2)*1.0)
            if nn_K >fea_sz[0]*0.6:
                 nn_K=np.round(fea_sz[0]*0.6)#33.6
            ###
            nn_K=nn_K.astype(np.int)
            with tf.device(gpu_id):
                 #### actual model
                 #mdl = cgcnn.cgcnn(**nn)
                 mdl_tr = graphtracker.GTTr(L1, nn_m, nn_d, nn_K, nn_p, nn_gamma)
                 mdl_te = graphtracker.GTTe(L1, nn_m, nn_d, nn_K, nn_p)    
                 sess_tr = tf.Session(config=config, graph = mdl_tr.graph) 
                 sess_te = tf.Session(config=config, graph = mdl_te.graph)
	    ####
            flag_occ = 0
            for jj in range(n_img):
		#### sampling patch
                im = np.copy(X0[jj,:,:,:])

		#################################################################
		##################### predict process ###########################
		#################################################################
                if jj > 0:
                    wsz,_,_ = fun_get_search_window2(cur_rct[2:],None,padding_h,padding_w)
                    search_offset = fun_get_search_ctr(wsz,factor=0.4)
                    noffset      = search_offset.shape[0]
                    nscale = search_scale.shape[0]
                    tmp_rcts = np.zeros((noffset*nscale,4))
                    response = np.zeros((noffset,nscale,nn_p,fea_sz[1],fea_sz[0]))

                    count = 0
                    for ioffset in range(noffset):
                        ctr0 = np.floor(search_offset[ioffset,0:2] + cur_rct[0:2]+0.5)
                        for iscale in range(nscale):
                            tmp_rcts[count,0:2] = np.copy(ctr0)
                            tmp_rcts[count,2:]  = np.floor(cur_rct[2:]*search_scale[iscale,:]+0.5) # 2016.12.11
                            count = count + 1
                    if jj == 1:
                        test_vgg_fea   = np.zeros((noffset*nscale,in_shape[1],in_shape[2],in_shape[3]),dtype=np.float32)
                        print("{}:{}:{}".format( search_scale, nscale, search_offset, noffset))
                    extract_feature(np.copy(im),tmp_rcts,test_vgg_fea)  
            
                    count = 0
                    for ioffset in range(noffset):
                        for iscale in range(nscale):
                            vgg_fea[0,:,:,:] = test_vgg_fea[count]
                            vgg_fea2 = fea_pca_te(vgg_fea[0], nn_p, pca_projections)
                            feed_dict = {mdl_te.ph_data: vgg_fea2, mdl_te.ws: model_alpha}
                            pred = sess_te.run(mdl_te.pred,feed_dict=feed_dict)
                            response[ioffset,iscale,:,:,:] = np.reshape(pred,(nn_p,fea_sz[1],fea_sz[0]))

                            count = count + 1

                    assert(response.shape[0]==1 and response.shape[1] == 1)
                    mx_offset = 0 #get_max_offset(response)
                    mx_scale = 0  #,mxress  = get_max_scale(response[mx_offset])
                    mx_layer, mxres_all  = get_max_scale(response[mx_offset, mx_scale])
                    #print mxress
                    ## compute ps offset 
                    mxres0 = np.zeros(nn_p)
                    mx_hh = np.zeros(nn_p)
                    mx_ww = np.zeros(nn_p)
                    for ilayer in range(nn_p):
                        mxres0[ilayer],mx_hh[ilayer],mx_ww[ilayer] = get_max_ps(response[mx_offset,mx_scale,ilayer,:,:],pmap_ctr_h,pmap_ctr_w)

                    ##
                    mx_w,mx_h,mxres = compute_hw(mx_hh,mx_ww,mxres0)

                    if jj > 5 and np.isnan(np.max(np.absolute(ws))) == False:
                        max_his = np.max(np.absolute(pred_rcts[jj-5:jj-1,0:2] - pred_rcts[jj-6:jj-2,0:2]))
                        max_his = np.max((max_his,1))
                        xx = np.max(np.absolute(np.asarray([mx_w,mx_h])*window_sz/fea_sz))

                    ####
                    pred_rcts[jj,2:] = np.floor(cur_rct[2:]*search_scale[mx_scale,:]+0.5) # ??
                    window_sz,_,_ = fun_get_search_window2(pred_rcts[jj,2:],None,padding_h,padding_w) # ??
                    pred_rcts[jj,0:2] = cur_rct[0:2] + 1.0*np.asarray([mx_w,mx_h])*window_sz/fea_sz + search_offset[mx_offset,:]
                    pred_rcts[jj,:] = fun_border_modification(np.copy(pred_rcts[jj,:]),im.shape[0],im.shape[1]) ## ????
                    cur_rct = np.copy(pred_rcts[jj,:])

                    ####
                    str1 = "[%3d]:[%3.2f,%3.2f,%3.2f,%3.2f],[%3.2f,%3.2f,%3.2f,%3.2f],[%.2f,%.2f,%.2f], [%d, %.3f]\n\t\t[%d,%.4f,%.2f,%.2f]\n\t\t%s\n\t\t%s\n\t\t%s" %(jj,\
                                      gt_rcts[jj,0],gt_rcts[jj,1],gt_rcts[jj,2],gt_rcts[jj,3],\
                                      pred_rcts[jj,0], pred_rcts[jj,1],pred_rcts[jj,2],pred_rcts[jj,3],\
                                      mx_offset,search_scale[mx_scale,0],search_scale[mx_scale,1],flag_occ,update_factor,\
                                      mx_layer,mxres, mx_w, mx_h, \
                                      vector2string(mx_ww,'float'),\
                                      vector2string(mx_hh,'float'),\
                                      vector2string(mxres0,'float'))

                    logger.info(str1)
                    flag_occ = 0

                    str1 = '%04d.jpg' %(jj) #'T_%d.jpg'
                    fname = os.path.join(save_path,str1)
                    fun_draw_rct_on_image(X0[jj,:,:],fname,gt_rcts[jj,:],None,pred_rcts[jj,:])

                    str1 = 'T_%d_mask.jpg' %(jj)
                    fname = os.path.join(save_path,str1)

                    str1 = 'prop_tr_%s_%d_%d.mat' %(fdr,iseq,jj)
                    fname = os.path.join(save_path,str1)

 
		#################################################################
		########################### Preparing ###########################
		#################################################################
                patch_t = extract_feature(np.copy(im),np.expand_dims(cur_rct,0),vgg_fea)
                if jj == 0: # pca
                     #pdb.set_trace()
                     pca_projections = fea_pca_tr(np.copy(vgg_fea[0]), nn_p, pca_energy, pca_is_mean, pca_is_norm)
                     
                vgg_fea2 = fea_pca_te(np.copy(vgg_fea[0]), nn_p, pca_projections)
 
		################### update model  ###################################
                if (jj%cf_nframe_update == 0 or jj < 5): 
                    with tf.device(gpu_id):
                        feed_dict = {mdl_tr.ph_data: vgg_fea2, mdl_tr.ph_labels: pmap}
                        ws, xlist = sess_tr.run([mdl_tr.ws,mdl_tr.xlist],feed_dict)
                        #pdb.set_trace()
                        #print("ws_shape:{}".format(ws.shape)) 
                        if jj==0:
                            model_alpha = np.copy(ws)
                            model_x =np.copy(vgg_fea2)
                        else:
                            if np.isnan(np.max(np.absolute(ws))) == False:
                                model_alpha = (1-update_factor)*model_alpha + update_factor*ws
                                model_x     = (1-update_factor)*model_x    + update_factor*vgg_fea2
                                #falg_occ = 1
                            else:
                                flag_occ = 1
 
	    ## save all results
            sess_tr.close()
            sess_te.close()
            if jj==n_img-1:
                pcs_loc_mean,pcs_loc_curv, pcs_loc_diff = fun_precision_location(pred_rcts,gt_rcts)
                pcs_olp_mean,pcs_olp_curv, pcs_olp_diff = fun_precision_overlap(pred_rcts,gt_rcts)
                str1 = '[%s, %d, %.3f]--[%.4f,%.4f]\n' %(fdr,iseq, update_factor, pcs_loc_mean,pcs_olp_mean),\
                                        np.array2string(pcs_loc_curv.transpose(),precision=4,separator=', '),\
                                        np.array2string(pcs_olp_curv.transpose(),precision=4,separator=', ') 
                logger.info(str1)
                close_logger(logger)

                str1 = 'result_%s_%d_%.3f.mat' %(fdr,iseq,update_factor)
                fname = os.path.join(cache_path,str1)
                save_mat_file(fname,gt_rcts,pred_rcts,pcs_loc_diff,pcs_olp_diff)
 
    vgg_sess.close()
     
